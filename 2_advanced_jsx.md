# Advanced jsx

##  class vs className
Грамматика в JSX в основном такая же, как и в HTML, но есть небольшие различия, на которые следует обратить внимание. Вероятно, наиболее частым из них является слово class.

В HTML обычно используют classв качестве имени атрибута:
```
<h1 class="big">Hey</h1>
```
В JSX вы не можете использовать это слово class! Вы должны использовать classNameвместо:
```
<h1 className="big">Hey</h1>
```
Это потому, что JSX переводится на JavaScript и classявляется зарезервированным словом в JavaScript.

Когда визуализируется JSX, classNameатрибуты JSX автоматически отображаются как classатрибуты.

## Self-Closing Tags
Другой JSX 'gotcha' включает самозакрывающиеся теги .

Что такое самозакрывающийся тег?

Большинство элементов HTML используют два тега : открывающий тег ( div) и закрывающий тег ( /div). Однако некоторые элементы HTML, такие как img и input используют только один тег. Тег, который принадлежит элементу с одним тегом, не является открывающим или закрывающим тегом; это самозакрывающийся тег.

Когда вы пишете самозакрывающийся тег в HTML, необязательно включать косую черту непосредственно перед последней угловой скобкой
```
Fine in HTML with a slash:

  <br />

Also fine, without the slash:

  <br>
```
Но!

В JSX вы должны включить косую черту. Если вы напишите самозакрывающийся тег в JSX и забудете косую черту, вы получите ошибку:
```
Fine in JSX:

  <br />

NOT FINE AT ALL in JSX:

  <br>
```
## JavaScript In Your JSX In Your JavaScript

## Curly Braces in JSX
Вместо добавления 2 и 3 он вывел «2 + 3» в виде строки текста. Зачем?

Это произошло потому , что 2 + 3находится между ними h1 и /h1 метки.

Любой код между тегами элемента JSX будет читаться как JSX, а не как обычный JavaScript! JSX не добавляет числа - он читает их как текст, как HTML.

Вам нужен способ написать код, который говорит: «Даже если я нахожусь между тегами JSX, относись ко мне как к обычному JavaScript, а не как к JSX».

Вы можете сделать это, заключив код в фигурные скобки .
```
  <h1>{2 + 3}</h1>,
```

## Variables in JSX
Когда вы внедряете JavaScript в JSX, этот JavaScript является частью той же среды, что и остальная часть JavaScript в вашем файле.

Это означает, что вы можете получить доступ к переменным внутри выражения JSX, даже если эти переменные были объявлены снаружи.
```
const name = 'Gerdo';

// Access your variable 
// from inside of a JSX expression:
const greeting = <p>Hello, {name}!</p>;
```

## Variable Attributes in JSX
При написании JSX часто используют переменные для установки атрибутов .

Вот пример того, как это может работать:
```
// Use a variable to set the `height` and `width` attributes:

const sideLength = "200px";

const panda = (
  <img 
    src="images/panda.jpg" 
    alt="panda" 
    height={sideLength} 
    width={sideLength} />
);
```
Обратите внимание, что в этом примере img каждый из атрибутов получает свою собственную строку. Это может сделать ваш код более читабельным, если у вас много атрибутов на одном элементе.

Свойства объекта также часто используются для установки атрибутов:
```
const pics = {
  panda: "http://bit.ly/1Tqltv5",
  owl: "http://bit.ly/1XGtkM3",
  owlCat: "http://bit.ly/1Upbczi"
}; 

const panda = (
  <img 
    src={pics.panda} 
    alt="Lazy Panda" />
);

const owl = (
  <img 
    src={pics.owl} 
    alt="Unimpressed Owl" />
);

const owlCat = (
  <img 
    src={pics.owlCat} 
    alt="Ghastly Abomination" />
); 
```
## Event Listeners in JSX
Элементы JSX могут иметь прослушиватели событий , как и элементы HTML. Программирование в React означает постоянную работу со слушателями событий.

Вы создаете прослушиватель событий, присваивая элементу JSX специальный атрибут . Вот пример:
```
<img onClick={myFunc} />
```
Имя атрибута прослушивателя событий должно быть примерно таким onClickили onMouseOver: слово on, а также тип события, которое вы слушаете. Вы можете увидеть список действительных названий событий здесь .

Значение атрибута слушателя события должно быть функцией. Приведенный выше пример будет работать только в том случае, если myFuncдопустимая функция была определена в другом месте:
```
function myFunc() {
  alert('Make myFunc the pFunc... omg that was horrible i am so sorry');
}

<img onClick={myFunc} />
```
Обратите внимание, что в HTML имена прослушивателей событий пишутся строчными буквами, например, onclickили onmouseover. В JSX имена слушателей событий пишутся в camelCase, например, onClickили onMouseOver.

## JSX Conditionals: If Statements That Don't Work
Вот правило, которое вам нужно знать: вы не можете внедрить ifоператор в выражение JSX.
Причина в том, что JSX компилируется. Вам пока не нужно разбираться в его механике, но если вам интересно, вы можете узнать больше здесь .

Что если вы хотите, чтобы выражение JSX отображалось, но только при определенных обстоятельствах? Вы не можете ввести ifзаявление. Что ты можешь сделать?

## JSX Conditionals: If Statements That Do Work
Как вы можете написать условноеif выражение , если вы не можете внедрить оператор в JSX?

Ну, один из вариантов - написать ifзаявление, а не внедрять его в JSX.

Посмотрите на if.js . Следуйте ifзаявлению, от строки 6 до строки 18.

if.js работ, потому что слова ifи elseкоторые не вводят между тегами JSX. ifЗаявление находится на внешней стороне, и никакой инъекции JavaScript не требуется.

Это распространенный способ выражения условных выражений в JSX.

## JSX Conditionals: The Ternary Operator
Существует более компактный способ записи условных выражений в JSX: троичный оператор .

Тернарный оператор работает в React так же, как и в обычном JavaScript. Тем не менее, он обнаруживается в React на удивление часто.

Вспомните, как это работает: вы пишете x ? y : z, где x, y и z - все выражения JavaScript. Когда ваш код выполняется, xон оценивается как «правдивый» или «ложный». Если xэто правда, то весь троичный оператор возвращается y. Если xэто ложь, то весь троичный оператор возвращается z. Вот хорошее объяснение, если вам нужно освежиться.

Вот как вы можете использовать троичный оператор в выражении JSX:
```
const headline = (
  <h1>
    { age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }
  </h1>
);
```
## JSX Conditionals: &&
Мы рассмотрим один последний способ написания условных выражений в React: &&оператор.

Подобно троичному оператору, &&не является специфичным для React, но неожиданно часто появляется в React.

В последних двух уроках вы писали заявления, которые иногда превращали котенка, а иногда - собачку. &&бы не был лучшим выбором для этих уроков.

&&лучше всего работает в условных выражениях, которые иногда выполняют действие, а в других случаях вообще ничего не делают .
```
const tasty = (
  <ul>
    <li>Applesauce</li>
    { !baby && <li>Pizza</li> }
    { age > 15 && <li>Brussels Sprouts</li> }
    { age > 20 && <li>Oysters</li> }
    { age > 25 && <li>Grappa</li> }
  </ul>
);
```
Каждый раз, когда вы видите &&в этом примере, либо будет выполняться какой-то код, либо код не будет выполняться .

## .map in JSX
Метод массива .map()часто встречается в React. Хорошо привыкнуть использовать его вместе с JSX.

Если вы хотите создать список элементов JSX, то .map()часто это лучший выбор. Поначалу это может выглядеть странно:
```
const strings = ['Home', 'Shop', 'About Me'];

const listItems = strings.map(string => <li>{string}</li>);

<ul>{listItems}</ul>
```
В приведенном выше примере мы начинаем с массива строк. Мы вызываем .map()этот массив строк, и этот .map()вызов возвращает новый массив <li>s.

В последней строке примера обратите внимание, что {listItems}будет вычисляться массив, потому что это возвращаемое значение .map()! JSX <li>не обязательно должны быть в таком массиве, но они могут быть.
```
// This is fine in JSX, not in an explicit array:

<ul>
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
</ul>

// This is also fine!

const liArray = [
  <li>item 1</li>, 
  <li>item 2<li>, 
  <li>item 3</li>
];

<ul>{liArray}</ul>
```
